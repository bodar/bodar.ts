<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reactive Islands - Dataflow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.11.1/styles/intellij-light.min.css">
    <script type="importmap">
        {
            "imports": {
                "highlight.js/": "https://esm.run/highlight.js/"
            }
        }
    </script>
</head>
<body>

<div class="site-header">
    <h1>Dataflow</h1>
    <a href="https://github.com/bodar/bodar.ts/tree/master/packages/dataflow"><img alt="GitHub" src="https://img.shields.io/badge/github-repo-blue?logo=github"></a>
</div>

<nav class="docs-nav">
    <a href="index.html">Quick Start</a>
    <a href="setup.html">Setup</a>
    <a href="reactivity.html">Reactivity</a>
    <a href="inputs.html">Inputs</a>
    <a href="islands.html" class="active">Islands</a>
    <a href="examples/">Examples</a>
</nav>

<h1>Reactive Islands</h1>

<div class="note">
    <strong>Note:</strong> Reactive islands are a Dataflow-only feature. Observable Framework processes entire pages at build time and doesn't support isolated reactive scopes or runtime transformation. This makes Dataflow well-suited for progressive enhancement and HTML-over-the-wire architectures.
</div>

<p>By default, all reactive scripts on a page share a single <a href="reactivity.html#reactive-scope">reactive scope</a> - top-level variables can be referenced from anywhere. Reactive islands create isolated scopes where variables are contained within the island. This is perfect for:</p>

<ul>
    <li><strong>Server-side rendering</strong> - Add interactivity to server-rendered HTML without a full page reload</li>
    <li><strong>Partial hydration</strong> - Only hydrate the parts of the page that need interactivity</li>
    <li><strong>HTMX / Unpoly / Datastar</strong> - Works seamlessly with HTML-over-the-wire tools</li>
    <li><strong>Micro-frontends</strong> - Embed independent reactive components in any page</li>
</ul>

<h2>Basic Usage</h2>

<p>Add <code>is="reactive-island"</code> to any container element to create an isolated reactive scope:</p>

<pre><code class="language-html">&lt;div is="reactive-island"&gt;
    &lt;script type="module" is="reactive"&gt;
        import {mutable} from '@bodar/dataflow/runtime.ts';
        const count = mutable(0);
        const increment = () =&gt; count.value++;
        const decrement = () =&gt; count.value--;
    &lt;/script&gt;
    &lt;script type="module" is="reactive"&gt;
        &lt;div&gt;
            &lt;button onclick={decrement}&gt;-&lt;/button&gt;
            &lt;span style="margin: 0 1em"&gt;{count}&lt;/span&gt;
            &lt;button onclick={increment}&gt;+&lt;/button&gt;
        &lt;/div&gt;
    &lt;/script&gt;
&lt;/div&gt;</code></pre>

<h2>Live Example: Multiple Islands</h2>

<p>Each island below contains identical code - the same <code>count</code>, <code>increment</code>, and <code>decrement</code> declarations. Because each island has its own reactive scope, these variables don't conflict:</p>

<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
    <div class="card" is="reactive-island">
        <h3>Island A</h3>
        <script type="module" is="reactive">
            import {mutable} from '@bodar/dataflow/runtime.ts';
            const count = mutable(0);
            const increment = () => count.value++;
            const decrement = () => count.value--;
        </script>
        <script type="module" is="reactive">
            <div>
                <button onclick={decrement}>-</button>
                <span style="margin: 0 1em">{count}</span>
                <button onclick={increment}>+</button>
            </div>
        </script>
    </div>

    <div class="card" is="reactive-island">
        <h3>Island B</h3>
        <script type="module" is="reactive">
            import {mutable} from '@bodar/dataflow/runtime.ts';
            const count = mutable(100);
            const increment = () => count.value++;
            const decrement = () => count.value--;
        </script>
        <script type="module" is="reactive">
            <div>
                <button onclick={decrement}>-</button>
                <span style="margin: 0 1em">{count}</span>
                <button onclick={increment}>+</button>
            </div>
        </script>
    </div>

    <div class="card" is="reactive-island">
        <h3>Island C</h3>
        <script type="module" is="reactive">
            import {mutable} from '@bodar/dataflow/runtime.ts';
            const count = mutable(1000);
            const increment = () => count.value++;
            const decrement = () => count.value--;
        </script>
        <script type="module" is="reactive">
            <div>
                <button onclick={decrement}>-</button>
                <span style="margin: 0 1em">{count}</span>
                <button onclick={increment}>+</button>
            </div>
        </script>
    </div>
</div>

<div class="note">
    <strong>Deployment tip:</strong> When using islands, prefer import maps over bundling. With a bundler, each island gets its own copy of the runtime. With an import map, all islands share the same pre-minified runtime (<script type="module" is="reactive">`${runtime.compressed} (${runtime.uncompressed} uncompressed)`</script>). See <a href="setup.html#choosing-your-approach">Setup</a> for details.
</div>

<h2>Integration with HTMX</h2>

<p>Reactive islands work perfectly with <a href="https://htmx.org/">HTMX</a>. When HTMX swaps in new HTML containing a reactive island, the island automatically initializes:</p>

<pre><code class="language-html">&lt;!-- Server returns this HTML fragment --&gt;
&lt;div is="reactive-island" hx-swap-oob="true" id="widget"&gt;
    &lt;script type="module" is="reactive"&gt;
        import {view} from '@bodar/dataflow/runtime.ts';
        const value = view(&lt;input type="range" min="0" max="100"/&gt;);
    &lt;/script&gt;
    &lt;script type="module" is="reactive"&gt;
        `Value: ${value}`
    &lt;/script&gt;
&lt;/div&gt;</code></pre>

<h2>Integration with Unpoly</h2>

<p><a href="https://unpoly.com/">Unpoly</a> can swap reactive islands just like any other fragment:</p>

<pre><code class="language-html">&lt;a href="/widget" up-target="#widget"&gt;Load Widget&lt;/a&gt;

&lt;div id="widget"&gt;
    &lt;!-- This will be replaced with a reactive island --&gt;
&lt;/div&gt;</code></pre>

<h2>Integration with Datastar</h2>

<p><a href="https://data-star.dev/">Datastar</a> uses Server-Sent Events to stream HTML updates. Reactive islands can be streamed as complete components:</p>

<pre><code class="language-html">&lt;!-- Streamed via SSE --&gt;
&lt;div is="reactive-island" data-star-swap="innerHTML"&gt;
    &lt;script type="module" is="reactive"&gt;
        // Self-contained reactive component
    &lt;/script&gt;
&lt;/div&gt;</code></pre>

<h2>How It Works</h2>

<p>When the HTML transformer encounters a <code>is="reactive-island"</code> element:</p>

<ol>
    <li>All <code>is="reactive"</code> scripts within are collected</li>
    <li>A dependency graph is built for just those scripts</li>
    <li>The runtime code is injected at the end of the island (not the body)</li>
    <li>Variables are scoped to the island - no conflicts with other islands or page-level scripts</li>
</ol>

<h2>Benefits Over Full SPA Frameworks</h2>

<table>
    <thead>
    <tr>
        <th>Aspect</th>
        <th>Full SPA</th>
        <th>Reactive Islands</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Initial page load</td>
        <td>Blank until JS loads</td>
        <td>Instant server-rendered content</td>
    </tr>
    <tr>
        <td>SEO</td>
        <td>Requires SSR setup</td>
        <td>Works out of the box</td>
    </tr>
    <tr>
        <td>Bundle size</td>
        <td>Large framework overhead</td>
        <td><script type="module" is="reactive">`${runtime.compressed} (${runtime.uncompressed} uncompressed)`</script> for runtime</td>
    </tr>
    <tr>
        <td>Hydration</td>
        <td>Full page hydration</td>
        <td>Only interactive parts</td>
    </tr>
    <tr>
        <td>Complexity</td>
        <td>Build pipeline required</td>
        <td>Optional - works at runtime</td>
    </tr>
    </tbody>
</table>

<script type="module" is="reactive">
    const runtime = fetch('https://dataflow.bodar.com/runtime.js')
        .then(async r => {
            const compressed = r.headers.get('content-length');
            const uncompressed = (await r.text()).length;
            return {
                compressed: `${Math.round(compressed / 1024)}KB`,
                uncompressed: `${Math.round(uncompressed / 1024)}KB`
            };
        });
</script>

<script type="module">
    import hljs from 'highlight.js/lib/core.js';
    import javascript from 'highlight.js/lib/languages/javascript';
    import xml from 'highlight.js/lib/languages/xml';

    hljs.registerLanguage('javascript', javascript);
    hljs.registerLanguage('xml', xml);
    hljs.highlightAll();
</script>

</body>
</html>
