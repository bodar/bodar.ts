<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reactivity - Dataflow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.11.1/styles/intellij-light.min.css">
    <script type="importmap">
        {
            "imports": {
                "highlight.js/": "https://esm.run/highlight.js/"
            }
        }
    </script>
</head>
<body>

<div class="site-header">
    <h1>Dataflow</h1>
    <a href="https://github.com/bodar/bodar.ts/tree/master/packages/dataflow"><img alt="GitHub"
                                                                                   src="https://img.shields.io/badge/github-repo-blue?logo=github"></a>
</div>

<nav class="docs-nav">
    <a href="index.html">Quick Start</a>
    <a href="setup.html">Setup</a>
    <a href="reactivity.html" class="active">Reactivity</a>
    <a href="inputs.html">Inputs</a>
    <a href="islands.html">Islands</a>
    <a href="examples/">Examples</a>
</nav>

<h1>Reactivity</h1>

<p>Dataflow runs like a spreadsheet: code re-runs automatically when referenced variables change. This brings:</p>

<ul>
    <li>Easier interactivity because state is automatically kept in sync</li>
    <li>Better performance with incremental re-rendering</li>
    <li>Greater flexibility by writing code in any order</li>
</ul>

<p>Unlike reactive libraries that require special APIs for every reactive value, Dataflow's core reactivity is
    implemented at the language layer with a minimal API. It's vanilla JavaScript, but the code runs automatically. Code
    blocks run in topological order determined by variable references (a.k.a. <em>dataflow</em>), rather than in
    top-down document order.</p>

<script type="module" is="reactive">
    import {display, view, input, mutable, observe, now, resize} from '@bodar/dataflow/runtime.ts';
</script>

<h2 id="reactive-scope">Reactive Scope</h2>

<p>All top-level variables declared in reactive scripts are shared within the same <strong>reactive scope</strong>. By
    default, the entire page is a single reactive scope - any top-level variable can be referenced from any other
    reactive script on the page.</p>

<p>For isolated scopes (useful with server-side rendering and HTML-over-the-wire tools like HTMX), see <a
        href="islands.html">Reactive Islands</a>.</p>

<h3>Top-level Variables</h3>

<p>A top-level variable declared in one reactive script can be referenced in another. So if you say:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>const x = 1, y = 2;</script>
</div>

<p>Then you can reference <code>x</code> and <code>y</code> elsewhere on the page. Top-level variable declarations are
    effectively <a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting">hoisted</a>:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>x + y</script>
</div>

<p>To prevent variables from being visible outside the current block, make them local with a block statement (curly
    braces):</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        {
            const z = 3;
            display(`z is ${z} but not visible outside this block`);
        }
    </script>
</div>

<h2>Promises</h2>

<p>Any promise declared in a reactive script is implicitly awaited when referenced from another code block. This means
    you can write asynchronous code without explicit <code>await</code> keywords across block boundaries.</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const data = fetch('https://api.github.com/repos/octocat/Hello-World')
            .then(r => r.json());
    </script>
    <script type="module" is="reactive" data-echo>
        `${data.name}: ${data.description}`
    </script>
</div>

<h2>Generators</h2>

<p>Values that change over time - such as interactive inputs, animation parameters, or streaming data - can be
    represented as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">generators</a>.
    When a top-level generator is declared, code in other blocks sees the generator's latest yielded value and re-runs
    each time the generator yields a new value.</p>

<div class="note">As with promises, implicit iteration of generators only applies <em>across</em> code blocks, not <em>within</em>
    a code block.
</div>

<h3>Synchronous Generators</h3>

<p>A synchronous generator without any explicit delays will yield once every <a
        href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">animation frame</a>,
    typically 60 times per second:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const i = function* () {
            for (let i = 0; true; ++i) {
                yield i;
            }
        }
    </script>
    <script type="module" is="reactive" data-echo>
        `Frame count: ${i}`
    </script>
</div>

<h3>Async Generators</h3>

<p>An async generator can control its own timing. Here's one that yields once per second:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const j = async function* () {
            for (let j = 0; true; ++j) {
                yield j;
                await new Promise((resolve) => setTimeout(resolve, 1000));
            }
        }
    </script>
    <script type="module" is="reactive" data-echo>
        `Seconds elapsed: ${j}`
    </script>
</div>

<h3>Animation Example</h3>

<p>Generators make animation declarative - the code runs automatically whenever the frame count changes:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        resize((width) => {
            const canvas = <canvas width={width} height="30"></canvas>;
            const context = canvas.getContext("2d");
            context.fillStyle = "#4269d0";
            context.fillRect((i % (canvas.width + 32)) - 32, 0, 32, 32);
            return canvas;
        })
    </script>
</div>

<h3>The now Generator</h3>

<p>Dataflow provides a built-in <code>now</code> generator that yields the current timestamp (<code>Date.now()</code>)
    on every animation frame:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        `The current time is ${new Date(now).toLocaleTimeString("en-GB")}.`
    </script>
</div>

<p>This is useful for animations, clocks, and any time-based reactive updates.</p>

<h2>Invalidation</h2>

<p>With reactive evaluation, code blocks can run multiple times in response to changing inputs. If a node returns a
    resource that needs cleanup when new inputs arrive, Dataflow handles this automatically.</p>

<div class="note">
    <strong>Note:</strong> Unlike Observable Framework where you must manually await an <code>invalidation</code>
    promise, Dataflow automatically cleans up values that are <code>AbortController</code>, <code>Symbol.dispose</code>,
    or <code>Symbol.asyncDispose</code>.
</div>

<ul>
    <li><strong>AbortController</strong> - <code>.abort()</code> is called</li>
    <li><strong>Symbol.dispose</strong> - the dispose function is called</li>
    <li><strong>Symbol.asyncDispose</strong> - the async dispose function is awaited</li>
</ul>

<h3>AbortController Example</h3>

<p>This example simulates a search API where broad queries (like "a") return more results and take longer, while specific queries (like "apple") return fewer results faster. Without cancellation, a slow broad query could return <em>after</em> a fast specific query and overwrite the results. Try typing quickly to see requests being aborted:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const query = view(<input type="text" placeholder="Type to search..." value="a"/>);
    </script>
    <script type="module" is="reactive" data-echo>
        // Fake API
        const search = async (query, signal) => {
            const length = Math.max(1, 100 - query.length * 15);
            const delay = length * 20;

            return new Promise((resolve) => {
                const id = setTimeout(() => resolve({ query, length, delay }), delay);
                signal.addEventListener('abort', () => {
                    clearTimeout(id);
                    resolve({ aborted: true, query } );
                }, {once: true});
            })
        };
    </script>
    <script type="module" is="reactive" data-echo>
        // When a new query is observed a new controller will be created and the old will be aborted automatically
        const controller = new AbortController();
        const results = search(query, controller.signal);
    </script>
    <script type="module" is="reactive" data-echo>
        results.aborted ? `Aborted: "${results.query}"` :
        `Found ${results.length} results for "${results.query}" (${results.delay}ms)`
    </script>
</div>

<h3>Disposable Example</h3>

<p>Using the standard <code>Symbol.dispose</code> protocol:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const resourceId = view(<input type="range" min="1" max="10" value="5"/>);
    </script>
    <script type="module" is="reactive" data-echo>
        const resource = {
            resourceId,
            [Symbol.dispose]() {
                display(`Disposed resource with id ${this.resourceId}`);
            }
        };
    </script>
    <script type="module" is="reactive" data-echo>
        `Resource id: ${resource.resourceId}`
    </script>
</div>

<h2>Observe</h2>

<p>The <code>observe</code> function is a general way to create a generator that "pushes" events asynchronously. It
    takes an initializer function and passes it a <code>notify</code> callback. The optional second argument provides an
    initial value, and the initializer can return a disposal function for cleanup:</p>

<div class="note">
    <strong>Note:</strong> Dataflow's <code>observe(init, initialValue, terminate)</code> adds two arguments beyond
    Observable Framework's <code>Generators.observe(init)</code>: <code>initialValue</code> yields immediately without
    calling <code>notify()</code>, and <code>terminate</code> is a predicate to stop iteration (defaults to stopping on
    <code>undefined</code>).
</div>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const pointer = observe((notify) => {
            const handler = (event) => notify([event.clientX, event.clientY]);
            document.addEventListener("pointermove", handler);
            return () => document.removeEventListener("pointermove", handler);
        }, [0, 0]);
    </script>
    <script type="module" is="reactive" data-echo>
        <span style="font-variant-numeric: tabular-nums">Pointer: [{pointer.map(Math.round).join(", ")}]</span>
    </script>
</div>

<h2>Resize</h2>

<p>The <code>resize</code> function creates a responsive container that automatically re-renders when its size changes.
    Pass a render function that receives the container's width (and optionally height) and returns a DOM node:</p>

<div class="note">
    <strong>Note:</strong> These examples just use a div for simplicity but you would not do this in practice as you
    could just use CSS, however if you had a chart that needed pixels
</div>

<div class="example">
    <script type="module" is="reactive" data-echo>
        resize((width) =>
            <div style={`box-sizing: border-box; width:${width}px; background: #4269d0; color: white; padding: 1em`}>
                Container width: {Math.round(width)}px
            </div>
        )
    </script>
</div>

<h3>resize() Signature</h3>

<pre><code class="language-typescript">function resize(
    render: (width: number, height?: number) => Node | string | null | Promise&lt;Node | string | null&gt;
): Node</code></pre>

<p>Parameters:</p>
<ul>
    <li><strong>render</strong> - Function called whenever the container resizes. Receives <code>width</code> and
        optionally <code>height</code>. If the function signature includes a second parameter, height tracking is
        enabled.
    </li>
</ul>

<h3>Width Only vs Width + Height</h3>

<p>The resize function inspects your render function's arity to determine behavior:</p>

<ul>
    <li><strong>1 parameter</strong> (<code>width</code>) - Only re-renders when width changes</li>
    <li><strong>2 parameters</strong> (<code>width, height</code>) - Re-renders on any size change; container has <code>height:
        100%</code>
    </li>
</ul>

<div class="example">
    <script type="module" is="reactive" data-echo>
        <div style="height: 10vh">
            {resize((width, height) =>
                <div style={`box-sizing: border-box; width:${width}px; height:${height}px; background: #4269d0; color: white; padding: 1em`}>
                    {Math.round(width)} x {Math.round(height)}
                </div>
            )}
        </div>
    </script>
</div>

<h3>Common Use Cases</h3>

<ul>
    <li><strong>Charts</strong> - Render SVG or Canvas at the container's exact dimensions</li>
    <li><strong>Responsive layouts</strong> - Adjust content based on available space</li>
    <li><strong>Animations</strong> - Combine with generators for responsive animated content</li>
</ul>

<h2 id="mutable">Mutable</h2>

<p>Normally, only the code block that declares a variable can modify it. Use <code>mutable</code> to create a reactive
    value that can be modified from other code blocks. This is similar to signals in other frameworks or
    <code>setState</code> in React - use it when you need state changes to flow back up the dependency graph:</p>

<div class="note">
    <strong>Note:</strong> In Observable Framework, <code>Mutable</code> is implicitly available. In Dataflow, you must
    import <code>mutable</code> from the runtime (like all other functions). Dataflow also adds an
    <code>update(fn)</code> method for functional updates, e.g. <code>list.update(arr => [...arr, item])</code>.
</div>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const count = mutable(0);
        const increment = () => count.value++;
        const reset = () => count.value = 0;
    </script>
    <script type="module" is="reactive" data-echo>
        <div>
            <button onclick={increment}>Increment</button>
            <button onclick={reset}>Reset</button>
            <span style="margin-left: 1em">Count: {count}</span>
        </div>
    </script>
</div>

<p>Within the defining code block, <code>count</code> is a <code>Mutable</code> object and <code>.value</code> can be
    read and written. In other code blocks, <code>count</code> yields the current value (not the Mutable object). To
    modify a mutable from another block, expose functions like <code>increment</code> and <code>reset</code> above.</p>

<script type="module">
    import hljs from 'highlight.js/lib/core.js';
    import javascript from 'highlight.js/lib/languages/javascript';
    import typescript from 'highlight.js/lib/languages/typescript';
    import xml from 'highlight.js/lib/languages/xml';

    hljs.registerLanguage('javascript', javascript);
    hljs.registerLanguage('typescript', typescript);
    hljs.registerLanguage('xml', xml);
    hljs.highlightAll();
</script>

</body>
</html>
