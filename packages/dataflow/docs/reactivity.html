<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reactivity - Dataflow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.11.1/styles/intellij-light.min.css">
    <script type="importmap">
        {
            "imports": {
                "highlight.js/": "https://esm.run/highlight.js/"
            }
        }
    </script>
</head>
<body>

<div class="site-header">
    <h1>Dataflow</h1>
    <a href="https://github.com/bodar/bodar.ts/tree/master/packages/dataflow"><img alt="GitHub"
                                                                                   src="https://img.shields.io/badge/github-repo-blue?logo=github"></a>
</div>

<nav class="docs-nav">
    <a href="index.html">Quick Start</a>
    <a href="setup.html">Setup</a>
    <a href="reactivity.html" class="active">Reactivity</a>
    <a href="inputs.html">Inputs</a>
    <a href="islands.html">Islands</a>
    <a href="examples/">Examples</a>
</nav>

<h1>Reactivity</h1>

<p>Dataflow runs like a spreadsheet: code re-runs automatically when referenced variables change. This brings:</p>

<ul>
    <li>Easier interactivity because state is automatically kept in sync</li>
    <li>Better performance with incremental re-rendering</li>
    <li>Greater flexibility by writing code in any order</li>
</ul>

<p>Unlike reactive libraries that require special APIs for every reactive value, Dataflow's core reactivity is
    implemented at the language layer with a minimal API. It's vanilla JavaScript, but the code runs automatically. Code
    blocks run in topological order determined by variable references (a.k.a. <em>dataflow</em>), rather than in
    top-down document order.</p>

<script type="module" is="reactive">
    import {display, view, input, event, mutable, observe, now, width, raw} from '@bodar/dataflow/runtime.ts';
</script>

<h2 id="reactive-scope">Reactive Scope</h2>

<p>All top-level variables declared in reactive scripts are shared within the same <strong>reactive scope</strong>. By
    default, the entire page is a single reactive scope - any top-level variable can be referenced from any other
    reactive script on the page.</p>

<p>For isolated scopes (useful with server-side rendering and HTML-over-the-wire tools like HTMX), see <a
        href="islands.html">Reactive Islands</a>.</p>

<h3>Top-level Variables</h3>

<p>A top-level variable declared in one reactive script can be referenced in another. So if you say:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>const x = 1, y = 2;</script>
</div>

<p>Then you can reference <code>x</code> and <code>y</code> elsewhere on the page. Top-level variable declarations are
    effectively <a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting">hoisted</a>:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>x + y</script>
</div>

<p>To prevent variables from being visible outside the current block, make them local with a block statement (curly
    braces):</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        {
            const z = 3;
            display(`z is ${z} but not visible outside this block`);
        }
    </script>
</div>

<h2>Promises</h2>

<p>Any promise declared in a reactive script is implicitly awaited when referenced from another code block. This means
    you can write asynchronous code without explicit <code>await</code> keywords across block boundaries.</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const data = fetch('https://api.github.com/repos/octocat/Hello-World')
            .then(r => r.json());
    </script>
    <script type="module" is="reactive" data-echo>
        `${data.name}: ${data.description}`
    </script>
</div>

<h2>Top-Level Await</h2>

<p>You can use <code>await</code> directly at the top level of a reactive script without wrapping it in an async
    function. This makes working with async APIs more natural:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const response = await fetch('https://api.github.com/repos/octocat/Hello-World');
        const repo = await response.json();
    </script>
    <script type="module" is="reactive" data-echo>
        `${repo.name}: ${repo.description}`
    </script>
</div>

<p>This is equivalent to the promise-based approach in the previous section, but often reads more clearly for sequential
    async operations.</p>

<h3 id="for-await-of">For Await...Of</h3>

<p>Top-level <code>for await...of</code> loops are also supported for iterating over async iterables:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const slow_source = raw(async function* () {
            let count = 0;
            while (true) {
                yield count++;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        });
    </script>
    <script type="module" is="reactive" data-echo>
        for await (const i of slow_source()) {
            display(i);
        }
    </script>
</div>

<h2>Generators</h2>

<p>Values that change over time - such as interactive inputs, animation parameters, or streaming data - can be
    represented as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">generators</a>.
    When a top-level generator is declared, code in other blocks sees the generator's latest yielded value and re-runs
    each time the generator yields a new value.</p>

<div class="note">As with promises, implicit iteration of generators only applies <em>across</em> code blocks, not <em>within</em>
    a code block.
</div>

<h3>Synchronous Generators</h3>

<p>A synchronous generator without any explicit delays will yield once every <a
        href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">animation frame</a>,
    typically 60 times per second:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const i = function* () {
            for (let i = 0; true; ++i) {
                yield i;
            }
        }
    </script>
    <script type="module" is="reactive" data-echo>
        `Frame count: ${i}`
    </script>
</div>

<h3>Async Generators</h3>

<p>An async generator can control its own timing. Here's one that yields once per second:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const j = async function* () {
            for (let j = 0; true; ++j) {
                yield j;
                await new Promise((resolve) => setTimeout(resolve, 1000));
            }
        }
    </script>
    <script type="module" is="reactive" data-echo>
        `Seconds elapsed: ${j}`
    </script>
</div>

<h3>Animation Example</h3>

<p>Generators make animation declarative - the code runs automatically whenever the frame count changes:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const canvas = display(<canvas width={width} height="32"></canvas>);
    </script>
    <script type="module" is="reactive" data-echo>
        const context = canvas.getContext("2d");
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = "#4269d0";
        context.fillRect((i % (canvas.width + 32)) - 32, 0, 32, 32);
    </script>
</div>

<h3>The now Generator</h3>

<p>Dataflow provides a built-in <code>now</code> generator that yields the current timestamp (<code>Date.now()</code>)
    on every animation frame:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        `The current time is ${new Date(now).toLocaleTimeString("en-GB")}.`
    </script>
</div>

<p>This is useful for animations, clocks, and any time-based reactive updates.</p>

<h3>The width Reactive Value</h3>

<p>Dataflow provides a built-in <code>width</code> reactive value that tracks the width of the code block's parent
    container. When the container resizes, any code referencing <code>width</code> automatically re-runs:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        <div style="background-color: #4269d0; color: white; padding: 1rem; box-sizing: border-box; width: 100%;">
            Container width: {width}px
        </div>
    </script>
</div>

<p>Try resizing your browser window to see the value update.</p>

<div class="note">
    <strong>Note:</strong> Dataflow's <code>width</code> tracks the <em>parent container's</em> width, not the window
    width. This is more useful for responsive components that need to adapt to their actual available space. It replaces
    Observable Framework's <code>resize()</code> function with a simpler API - just use <code>width</code> as a value.
</div>

<h4>Comparison with Observable Framework</h4>

<p>In Observable Framework, the implicit <code>width</code> variable tracks the <em>window</em> width (specifically the
    <code>&lt;main&gt;</code> element). Dataflow's <code>width</code> instead tracks each code block's parent container,
    which is more flexible for embedded components.</p>

<p>If you need window-level width (like Observable Framework), you can use <code>event</code> to create your own:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const windowWidth = event(window, "resize", () => window.innerWidth, window.innerWidth);
    </script>
    <script type="module" is="reactive" data-echo>
        `Window width: ${windowWidth}px`
    </script>
</div>

<h2>Invalidation</h2>

<p>With reactive evaluation, code blocks can run multiple times in response to changing inputs. If a node returns a
    resource that needs cleanup when new inputs arrive, Dataflow handles this automatically.</p>

<div class="note">
    <strong>Note:</strong> Unlike Observable Framework where you must manually await an <code>invalidation</code>
    promise, Dataflow automatically cleans up values that are <code>AbortController</code>, <code>Symbol.dispose</code>,
    or <code>Symbol.asyncDispose</code>.
</div>

<ul>
    <li><strong>AbortController</strong> - <code>.abort()</code> is called</li>
    <li><strong>Symbol.dispose</strong> - the dispose function is called</li>
    <li><strong>Symbol.asyncDispose</strong> - the async dispose function is awaited</li>
</ul>

<h3>AbortController Example</h3>

<p>This example simulates a search API where broad queries (like "a") return more results and take longer, while
    specific queries (like "apple") return fewer results faster. Without cancellation, a slow broad query could return
    <em>after</em> a fast specific query and overwrite the results. Try typing quickly to see requests being aborted:
</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const query = view(<input type="text" placeholder="Type to search..." value="a"/>);
    </script>
    <script type="module" is="reactive" data-echo>
        // Fake API
        const search = async (query, signal) => {
            const length = Math.max(1, 100 - query.length * 15);
            const delay = length * 20;

            return new Promise((resolve) => {
                const id = setTimeout(() => resolve({query, length, delay}), delay);
                signal.addEventListener('abort', () => {
                    clearTimeout(id);
                    resolve({aborted: true, query});
                }, {once: true});
            })
        };
    </script>
    <script type="module" is="reactive" data-echo>
        // When a new query is observed a new controller will be created and the old will be aborted automatically
        const controller = new AbortController();
        const results = search(query, controller.signal);
    </script>
    <script type="module" is="reactive" data-echo>
        results.aborted ? `Aborted: "${results.query}"` :
            `Found ${results.length} results for "${results.query}" (${results.delay}ms)`
    </script>
</div>

<h3>Disposable Example</h3>

<p>Using the standard <code>Symbol.dispose</code> protocol:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const resourceId = view(<input type="range" min="1" max="10" value="5"/>);
    </script>
    <script type="module" is="reactive" data-echo>
        const resource = {
            resourceId,
            [Symbol.dispose]() {
                display(`Disposed resource with id ${this.resourceId}`);
            }
        };
    </script>
    <script type="module" is="reactive" data-echo>
        `Resource id: ${resource.resourceId}`
    </script>
</div>

<h2>Observe</h2>

<p>The <code>observe</code> function is a general way to create a generator that "pushes" events asynchronously. It
    takes an initializer function and passes it a <code>notify</code> callback. The optional second argument provides an
    initial value, and the initializer can return a disposal function for cleanup:</p>

<div class="note">
    <strong>Note:</strong> Dataflow's <code>observe(init, initialValue, terminate)</code> adds two arguments beyond
    Observable Framework's <code>Generators.observe(init)</code>: <code>initialValue</code> yields immediately without
    calling <code>notify()</code>, and <code>terminate</code> is a predicate to stop iteration (defaults to stopping on
    <code>undefined</code>).
</div>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const pointer = observe((notify) => {
            const handler = (event) => notify([event.clientX, event.clientY]);
            document.addEventListener("pointermove", handler);
            return () => document.removeEventListener("pointermove", handler);
        }, [0, 0]);
        // NB: This can be also be defined with event function as a one-liner
        // const pointer = event(document, 'pointermove', ev => [ev.clientX, ev.clientY], [0, 0])
    </script>
    <script type="module" is="reactive" data-echo>
        <>Pointer: [{pointer.map(Math.round).join(", ")}]</>
    </script>
</div>

<h2 id="mutable">Mutable</h2>

<p>Normally, only the code block that declares a variable can modify it. Use <code>mutable</code> to create a reactive
    value that can be modified from other code blocks. This is similar to signals in other frameworks or
    <code>setState</code> in React - use it when you need state changes to flow back up the dependency graph:</p>

<div class="note">
    <strong>Note:</strong> In Observable Framework, <code>Mutable</code> is implicitly available. In Dataflow, you must
    import <code>mutable</code> from the runtime (like all other functions). Dataflow also adds an
    <code>update(fn)</code> method for functional updates, e.g. <code>list.update(arr => [...arr, item])</code>.
</div>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const count = mutable(0);
        const increment = () => count.value++;
        const reset = () => count.value = 0;
    </script>
    <script type="module" is="reactive" data-echo>
        <div>
            <button onclick={increment}>Increment</button>
            <button onclick={reset}>Reset</button>
            <span style="margin-left: 1em">Count: {count}</span>
        </div>
    </script>
</div>

<p>Within the defining code block, <code>count</code> is a <code>Mutable</code> object and <code>.value</code> can be
    read and written. In other code blocks, <code>count</code> yields the current value (not the Mutable object). To
    modify a mutable from another block, expose functions like <code>increment</code> and <code>reset</code> above.</p>

<h2 id="raw">Raw</h2>

<p>Dataflow automatically processes certain values when they flow between reactive blocks - promises are awaited,
    generators are iterated, and their yielded values trigger re-evaluation. Sometimes you want to pass these values
    through <em>without</em> this automatic processing. The <code>raw</code> function marks a value to be passed as-is:</p>

<div class="example">
    <script type="module" is="reactive" data-echo>
        const generatorFn = raw(function* () {
            yield 1;
            yield 2;
            yield 3;
        });
    </script>
    <script type="module" is="reactive" data-echo>
        // generatorFn is the function itself, not an iterated value
        const values = [...generatorFn()];
        `Values: ${values.join(', ')}`
    </script>
</div>

<p>This is particularly useful when you want to:</p>
<ul>
    <li>Pass a generator function to be called and iterated manually (as in the <a href="#for-await-of">for await...of</a> example above)</li>
    <li>Store a promise without awaiting it</li>
    <li>Pass async iterables to be consumed with explicit iteration</li>
</ul>

<div class="note">
    <strong>Note:</strong> Without <code>raw</code>, a generator assigned to a top-level variable would be automatically
    iterated by Dataflow, with each yielded value triggering dependent blocks to re-run. With <code>raw</code>, you get
    the generator function itself.
</div>

<script type="module">
    import hljs from 'highlight.js/lib/core.js';
    import javascript from 'highlight.js/lib/languages/javascript';
    import typescript from 'highlight.js/lib/languages/typescript';
    import xml from 'highlight.js/lib/languages/xml';

    hljs.registerLanguage('javascript', javascript);
    hljs.registerLanguage('typescript', typescript);
    hljs.registerLanguage('xml', xml);
    hljs.highlightAll();
</script>

</body>
</html>
