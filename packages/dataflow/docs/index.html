<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dataflow Quick Start</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.6;
        }
        h1, h2, h3 { margin-top: 2rem; }
        p { margin: 1rem 0; }
        code { background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 3px; }
        .example {
            border: 1px solid #ddd;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
            background: #fafafa;
        }
        .note {
            background: #e8f4fd;
            border-left: 4px solid #1976d2;
            padding: 1rem;
            margin: 1rem 0;
        }
        .tip {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 1rem;
            margin: 1rem 0;
        }
        input, select {
            font-family: inherit;
            font-size: inherit;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 0.3em 0.5em;
            background-color: #fff;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #1976d2;
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
        }
    </style>
</head>
<body>

<h1>Dataflow</h1>

<p>Dataflow is a lightweight reactive JavaScript library inspired by <a href="https://observablehq.com/framework/">Observable Framework</a>. It brings reactive programming to plain HTML pages with minimal overhead - the core library (including JSX support) is under 3KB compressed.</p>

<p>Just add a single <code>data-reactive</code> attribute to any script tag and it becomes reactive. That's it.</p>

<p>It works like a spreadsheet: just reference a value from another reactive script tag, and the plumbing happens automatically. No <code>setState</code>, no Redux, no reducers, no manual subscriptions. Just declarative dependencies.</p>

<div class="tip">The transformation can happen at build time, at runtime on the server, at the edge, or even client-side using a service worker.</div>

<h2>Reactive Script Blocks</h2>

<p>Reactive script blocks come in two forms: <em>expression</em> blocks and <em>program</em> blocks. An expression block contains a single expression:</p>

<div class="example">
    <script type="module" data-reactive>1 + 2</script>
</div>

<p>Expression blocks implicitly display their result.</p>

<p>A program block contains statements like variable declarations:</p>

<div class="example">
    <script type="module" data-reactive>const foo = 1 + 2;</script>
    <p>The variable <code>foo</code> is defined but nothing is displayed.</p>
</div>

<p>A program block doesn't display anything by default, but you can import and call <code>display</code> to display something.</p>

<h2>DOM Nodes</h2>

<p>If an expression evaluates to a DOM node, the node is inserted into the page. Use this to create dynamic content.</p>

<div class="example">
    <script type="module" data-reactive>document.createTextNode("[insert chart here]")</script>
</div>

<h2>JSX</h2>

<p>JSX is supported for creating DOM elements with a familiar syntax. Under the hood, JSX compiles directly to native DOM methods using the <a href="https://jsr.io/@bodar/jsx2dom">@bodar/jsx2dom</a> library - no virtual DOM, no framework overhead.</p>

<p>For example, here's a component that displays a greeting:</p>

<div class="example">
    <script type="module" data-reactive>
        const greeting = (name) => <i>Hello, {name}!</i>
    </script>
    <script type="module" data-reactive>greeting("world")</script>
</div>

<p>JSX attributes work as expected, including dynamic values:</p>

<div class="example">
    <script type="module" data-reactive>
        const color = "blue";
    </script>
    <script type="module" data-reactive>
        <span style={`color: ${color}; font-weight: bold`}>Styled with JSX</span>
    </script>
</div>

<h2>Reactivity with Generators</h2>

<p>Code blocks automatically re-run when referenced reactive variables change. The block below references a <code>now</code> variable representing the current time in milliseconds; because <code>now</code> is reactive (defined as a generator), this block runs continuously.</p>

<div class="example">
    <script type="module" data-reactive>
        const now = function* () {
            while (true) {
                yield Date.now();
            }
        }
    </script>
    <script type="module" data-reactive>
        <span style={`color: hsl(${(now / 10) % 360} 100% 50%)`}>Rainbow text!</span>
    </script>
</div>

<h2>Explicit Display</h2>

<p>The <code>display</code> function displays the specified value.</p>

<div class="example">
    <script type="module" data-reactive>
        import {display} from "@bodar/dataflow/api/display.ts";
        const x = Math.random();
        display(x);
    </script>
</div>

<p>Calling <code>display</code> multiple times will display multiple values. Values are displayed in the order they are received.</p>

<div class="example">
    <script type="module" data-reactive>
        import {display} from "@bodar/dataflow/api/display.ts";
        for (let i = 0; i < 5; ++i) {
            display(i);
        }
    </script>
</div>

<p>If you pass <code>display</code> a DOM node, it will be inserted directly into the page.</p>

<div class="example">
    <script type="module" data-reactive>
        import {display} from "@bodar/dataflow/api/display.ts";
        display(<span>Your lucky number is {Math.floor(Math.random() * 10)}!</span>);
    </script>
</div>

<p>The <code>display</code> function returns the passed-in value. You can display any value in code; use this as an alternative to <code>console.log</code> to debug your code.</p>

<div class="example">
    <script type="module" data-reactive>
        import {display} from "@bodar/dataflow/api/display.ts";
        const y = display(Math.random());
    </script>
    <p>The value of <code>y</code> is captured and can be used by other cells.</p>
</div>

<h2>Implicit Display</h2>

<p>JavaScript expression blocks are implicitly wrapped with a call to <code>display</code>. For example, this arithmetic expression displays implicitly:</p>

<div class="example">
    <script type="module" data-reactive>1 + 2</script>
</div>

<p>Implicit display only applies when the code block contains a single expression. Statements like variable declarations don't implicitly display:</p>

<div class="example">
    <script type="module" data-reactive>const foo = 1 + 2;</script>
    <p>(Nothing displayed above - variable declarations are statements, not expressions)</p>
</div>

<div class="note">
    <strong>Note:</strong> This differs from Observable Framework. We use AST parsing to detect whether the code is a single expression versus a statement.
    Semi colons are optional, Prettier will not break anything.
</div>

<h2>Reactive Inputs with view()</h2>

<p>The <code>view</code> function combines <code>display</code> and <code>input</code> to create reactive inputs. When the input changes, dependent code re-runs.</p>

<h3>Using Plain JSX Inputs</h3>

<div class="example">
    <script type="module" data-reactive>
        import {view} from "@bodar/dataflow/api/view.ts";
        const name = view(<input name="name" type="text" value="World" />);
    </script>
    <script type="module" data-reactive>`Hello, ${name}!`</script>
</div>

<h3>Using Observable Inputs</h3>

<p>You can also use the <code>@observablehq/inputs</code> library for more sophisticated input controls.</p>

<div class="example">
    <script type="module" data-reactive>
        import {range} from "@observablehq/inputs";
        import {view} from "@bodar/dataflow/api/view.ts";
        const slider = view(range([0, 100], {label: "Value", step: 1, value: 50}));
    </script>
    <script type="module" data-reactive>`The slider value is: ${slider}`</script>
</div>

<h3>Multiple Inputs</h3>

<div class="example">
    <script type="module" data-reactive>
        import {view} from "@bodar/dataflow/api/view.ts";
        const a = view(<input type="number" value="10" style="width: 60px" />);
    </script>
    <script type="module" data-reactive>
        import {view} from "@bodar/dataflow/api/view.ts";
        const b = view(<input type="number" value="5" style="width: 60px" />);
    </script>
    <script type="module" data-reactive>
        <span>{a} + {b} = {a + b}</span>
    </script>
</div>

<h2>Different Input Types</h2>

<h3>Checkbox</h3>

<div class="example">
    <script type="module" data-reactive>
        import {view} from "@bodar/dataflow/api/view.ts";
        const checked = view(<input type="checkbox" id="feature"/>);
    </script>
    <label for="feature">
        <script type="module" data-reactive>`Feature is ${checked ? 'enabled' : 'disabled'}`</script>
    </label>
</div>

<h3>Select</h3>

<div class="example">
    <script type="module" data-reactive>
        import {view} from "@bodar/dataflow/api/view.ts";
        const color1 = view(
            <select>
                <option value="red">Red</option>
                <option value="green">Green</option>
                <option value="blue">Blue</option>
            </select>
        );
    </script>
    <script type="module" data-reactive>
        <span style={`color: ${color1}; font-weight: bold`}>Selected color: {color1}</span>
    </script>
</div>

<h2>Combining Multiple Reactive Values</h2>

<p>Reactive values can depend on multiple inputs. The dependent code re-runs whenever any input changes.</p>

<div class="example">
    <script type="module" data-reactive>
        import {view} from "@bodar/dataflow/api/view.ts";
        const width = view(<input type="range" min="50" max="300" value="150" />);
    </script>
    <script type="module" data-reactive>
        import {view} from "@bodar/dataflow/api/view.ts";
        const height = view(<input type="range" min="50" max="200" value="100" />);
    </script>
    <script type="module" data-reactive>
        import {view} from "@bodar/dataflow/api/view.ts";
        const color2 = view(<input type="color" value="#4a90d9" />);
    </script>
    <script type="module" data-reactive>
        <div style={`width: ${width}px; height: ${height}px; background: ${color2}; display: flex; align-items: center; justify-content: center; color: white; text-shadow: 1px 1px 2px black`}>
            {width} x {height}
        </div>
    </script>
</div>

<h2>Current Time Display</h2>

<p>A classic example showing reactive updates with a time generator.</p>

<div class="example">
    <script type="module" data-reactive>
        const time = function* () {
            while (true) {
                yield Date.now();
            }
        }
    </script>
    <script type="module" data-reactive>
        `The current time is ${new Date(time).toLocaleTimeString("en-GB")}.`
    </script>
</div>

</body>
</html>
